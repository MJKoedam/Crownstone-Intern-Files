'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Format = require('./Format');

var _require = require('./utils'),
    adjustLevel = _require.adjustLevel,
    LEVELS = _require.LEVELS,
    LOG = _require.LOG,
    DEBUG = _require.DEBUG,
    INFO = _require.INFO,
    WARN = _require.WARN,
    ERROR = _require.ERROR,
    FATAL = _require.FATAL;

var Namespaces = require('./Namespaces');

function LogBase(name, opts) {
  Object.assign(this, {
    name: name,
    opts: opts,
    _enabled: {},
    formatter: new Format(opts)
  });
  this.enable();
}

LogBase.prototype = {
  enable: function enable(namespaces) {
    var _this = this;

    namespaces = namespaces || this.opts.namespaces;
    var namespace = new Namespaces(namespaces);
    this._enabled = {}; // reset
    var level = namespace.isEnabled(this.name, this.opts.level);
    if (level) {
      LEVELS[adjustLevel(level, DEBUG)].forEach(function (level) {
        _this._enabled[level] = true;
      });
    }
  },


  get enabled() {
    var _this2 = this;

    return this._enabled._cache || (this._enabled._cache = LEVELS[DEBUG].reduce(function (o, level) {
      o[level] = o[level.toLowerCase()] = !!_this2._enabled[level];
      return o;
    }, {}));
  },

  log: function log() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // always log
    return this._log(LOG, args);
  },
  debug: function debug() {
    if (!this._enabled.DEBUG) return;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return this._log(DEBUG, args);
  },
  info: function info() {
    if (!this._enabled.INFO) return;

    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return this._log(INFO, args);
  },
  warn: function warn() {
    if (!this._enabled.WARN) return;

    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return this._log(WARN, args);
  },
  error: function error() {
    if (!this._enabled.ERROR) return;

    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return this._log(ERROR, args);
  },
  fatal: function fatal() {
    if (!this._enabled.FATAL) return;

    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return this._log(FATAL, args);
  },
  _serverinfo: function _serverinfo() {},


  /**
   * @return {object} json object
   */
  _formatJson: function _formatJson(level, _args) {
    var _formatter;

    var args = _args.slice(); // work on copy
    var opts = this.opts;

    var o = {
      level: level,
      name: this.name,
      msg: undefined
    };

    var loop = true;

    while (loop && args.length) {
      // remove object only formats
      if (/^\s*%[oOj]\s*$/.test(args[0])) {
        args.shift();
      }

      switch (_typeof(args[0])) {
        case 'string':
          loop = false;
          args = (_formatter = this.formatter).format.apply(_formatter, _toConsumableArray(args));
          o.msg = args.shift();
          break;
        case 'object':
          if (args[0] instanceof Error) {
            (function () {
              var err = args.shift();
              o.err = {
                name: err.name,
                stack: err.stack
              };
              o.msg = err.message;
              // append other keys
              Object.keys(err).forEach(function (key) {
                o.err[key] = err[key];
              });
            })();
          } else {
            var obj = args.shift();
            if (Array.isArray(obj)) {
              o.arr = obj;
            } else {
              Object.assign(o, obj);
            }
          }
          break;
        default:
          loop = false;
          o.msg = args.shift();
          break;
      }
    }

    // any other arguments are added to `.args`
    if (args.length) {
      o.args = args;
    }
    // we put serverinfo and date at the end of the object
    // for not viewing the same info e.g. if in tty
    if (opts.serverinfo) this._serverinfo(o);
    if (!opts.hideDate) o.time = new Date().toISOString();
    // diff info is not in humanized form
    o.diff = this.diff;
    // ensure core fields
    o.level = level;
    o.name = this.name;

    return o;
  },
  _diff: function _diff() {
    var curr = Date.now();
    var prev = this.prev || curr;
    this.diff = curr - prev;
    this.prev = curr;
  },
  _log: function _log() /* level, args */{
    /* istanbul ignore next */
    throw new Error('needs implementation');
  }
};

module.exports = LogBase;