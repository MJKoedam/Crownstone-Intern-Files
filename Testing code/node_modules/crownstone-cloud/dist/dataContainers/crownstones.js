"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cache_1 = require("../tools/cache");
class Crownstones {
    constructor(cloudRequestor, spheres = null, locations = null, crownstoneIdentifier = null) {
        this.locations = null;
        this.spheres = null;
        this.filter = null;
        this.stoneIds = [];
        this.rest = cloudRequestor;
        this.spheres = spheres;
        this.locations = locations;
        this.filter = crownstoneIdentifier;
    }
    async refresh() {
        await this.downloadAllCrownstones();
        return this;
    }
    async downloadAllCrownstones() {
        var _a, _b;
        let stones = await this.rest.getCrownstones();
        let filteredResult = [];
        let sphereIds = ((_a = this.spheres) === null || _a === void 0 ? void 0 : _a.sphereIds) || [];
        let locationIds = ((_b = this.locations) === null || _b === void 0 ? void 0 : _b.locationIds) || [];
        this.rest.cache.crownstones = {};
        stones.forEach((stone) => {
            this.rest.cache.crownstones[stone.id] = stone;
            if (sphereIds.indexOf(stone.sphereId) !== -1 || sphereIds.length === 0) {
                if (locationIds.indexOf(stone.locationId) !== -1 || locationIds.length === 0) {
                    filteredResult.push(stone);
                }
            }
        });
        return filteredResult;
    }
    id(id) {
        this.stoneIds = [id];
        return this;
    }
    /**
     * this method will ensure we know which ID's to use for this request.
     */
    async prepare() {
        if (this.stoneIds.length !== 0) {
            return;
        }
        // the data method gets all required data to figure out which crownstones to switch.
        await this.data();
    }
    async setMultiSwitch(switchData) {
        throw 'setMultiSwitch is not implemented yet';
    }
    async currentSwitchState() {
        await this.prepare();
        if (this.stoneIds.length === 0) {
            return 0;
        }
        if (this.stoneIds.length > 1) {
            throw "For multiple Crownstones, use .currentSwitchStateData()";
        }
        let stoneId = this.stoneIds[0];
        let data = await this.rest.getCurrentSwitchState(stoneId);
        let switchState = data.switchState || 0;
        if (switchState > 0 && switchState <= 1) {
            return switchState * 100;
        }
        return data.switchState;
    }
    async currentSwitchStateData() {
        let switchStateData = {};
        let data = await this.data();
        for (let i = 0; i < data.length; i++) {
            let stoneItem = data[i];
            let switchState = stoneItem.currentSwitchState.switchState || 0;
            if (switchState > 0 && switchState <= 1) {
                switchState *= switchState * 100;
            }
            stoneItem.currentSwitchState.switchState = switchState;
            switchStateData[stoneItem.id] = stoneItem.currentSwitchState;
        }
        return switchStateData;
    }
    async setSwitch(value) {
        await this._switch({ type: "PERCENTAGE", percentage: value });
    }
    async turnOn() {
        await this._switch({ type: "TURN_ON" });
    }
    async turnOff() {
        await this._switch({ type: "TURN_OFF" });
    }
    async _switch(switchData) {
        await this.prepare();
        if (this.stoneIds.length === 0) {
            return;
        }
        let value = switchData.percentage;
        // normalize value
        if (value > 0 && value <= 1) {
            value *= 100;
        }
        value = Math.max(0, Math.min(100, value));
        if (this.stoneIds.length > 1) {
            let list = [];
            for (let i = 0; i < this.stoneIds.length; i++) {
                let stoneId = this.stoneIds[i];
                if (this.rest.cache.crownstones[stoneId] === undefined) {
                    await this.refresh();
                }
                // this can happen if a stone is deleted.
                if (this.rest.cache.crownstones[stoneId] !== undefined) {
                    let stone = this.rest.cache.crownstones[stoneId];
                    list.push({ sphereId: stone.sphereId, type: switchData.type, stoneId: stoneId, percentage: value });
                }
            }
            return await this.setMultiSwitch(list);
        }
        await this.rest.switchCrownstone(this.stoneIds[0], { type: switchData.type, percentage: value });
    }
    _searchInCache() {
        var _a, _b;
        let sphereIds = ((_a = this.spheres) === null || _a === void 0 ? void 0 : _a.sphereIds) || [];
        let locationIds = ((_b = this.locations) === null || _b === void 0 ? void 0 : _b.locationIds) || [];
        let stones = this.rest.cache.findCrownstones(this.filter);
        let found = false;
        if (stones.length > 0) {
            stones.forEach((stone) => {
                if (sphereIds.indexOf(stone.sphereId) !== -1 || sphereIds.length === 0) {
                    if (locationIds.indexOf(stone.locationId) !== -1 || locationIds.length === 0) {
                        this.stoneIds.push(stone.id);
                        found = true;
                    }
                }
            });
        }
        return found;
    }
    async resolveIdentifier() {
        var _a, _b, _c, _d;
        this.stoneIds = [];
        let result = this._searchInCache();
        if (result) {
            return;
        }
        if (typeof this.filter === 'string') {
            // possibly ID
            if (this.filter.length === 24) {
                try {
                    let stone = await this.rest.getCrownstone(this.filter);
                    this.rest.cache.crownstones[stone.id] = stone;
                    this.stoneIds.push(stone.id);
                    return;
                }
                catch (e) {
                    // 401 means this id does not exist
                    if (((_d = (_c = (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.request) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.statusCode) !== 401) {
                        throw e;
                    }
                }
            }
        }
        // if we do not have any sphere with this description, check if we have to download all of them.
        if (this.rest.cache.downloadedAll['crownstones'] === false) {
            await this.downloadAllCrownstones();
            let result = this._searchInCache();
            if (result) {
                return;
            }
        }
        throw { code: 404, type: "crownstones", message: "Could not find Crownstones(s) with this filter: " + this.filter };
    }
    async data() {
        var _a, _b, _c, _d;
        let sphereIds = ((_a = this.spheres) === null || _a === void 0 ? void 0 : _a.sphereIds) || [];
        let sphereFilter = ((_b = this.spheres) === null || _b === void 0 ? void 0 : _b.filter) || null;
        let locationIds = ((_c = this.locations) === null || _c === void 0 ? void 0 : _c.locationIds) || [];
        let locationFilter = ((_d = this.locations) === null || _d === void 0 ? void 0 : _d.filter) || null;
        if (sphereFilter !== null && sphereIds.length === 0) {
            // we need to identify the spheres
            await this.spheres.resolveIdentifier();
            return this.data();
        }
        else if (locationFilter !== null && locationIds.length === 0) {
            // we need to identify the locations
            await this.locations.resolveIdentifier();
            return this.data();
        }
        else if (this.filter !== null && this.stoneIds.length === 0) {
            // we need to identify the crownstones
            await this.resolveIdentifier();
            return await this.data();
        }
        else if (this.filter === null) {
            if (this.rest.cache.downloadedAll['crownstones']) {
                return this._getFilteredData();
            }
            // not cached, download now.
            await this.downloadAllCrownstones();
            return await this.data();
        }
        // if we are here, we have all required ids. We also have downloaded all required Crownstones.
        // all that is left to do is to filter the result from the cache.
        return this._getFilteredData();
    }
    _getFilteredData() {
        var _a, _b;
        let sphereIds = ((_a = this.spheres) === null || _a === void 0 ? void 0 : _a.sphereIds) || [];
        let locationIds = ((_b = this.locations) === null || _b === void 0 ? void 0 : _b.locationIds) || [];
        let itemsInCache = cache_1.listCacheItemsInSphereInLocation(this.rest.cache.crownstones, sphereIds, locationIds, this.stoneIds);
        this.stoneIds = [];
        for (let i = 0; i < itemsInCache.length; i++) {
            this.stoneIds.push(itemsInCache[i].id);
        }
        return itemsInCache;
    }
}
exports.Crownstones = Crownstones;
//# sourceMappingURL=crownstones.js.map