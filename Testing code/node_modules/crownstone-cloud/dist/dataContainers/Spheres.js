"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cache_1 = require("../tools/cache");
const crownstones_1 = require("./crownstones");
const locations_1 = require("./locations");
class Spheres {
    constructor(cloudRequestor, filter = null) {
        this.filter = null;
        this.sphereIds = [];
        this.rest = cloudRequestor;
        this.filter = filter;
    }
    async downloadAllSpheres() {
        let spheres = [];
        if (this.rest.isUser()) {
            spheres = await this.rest.getSpheres();
        }
        else if (this.rest.isHub()) {
            spheres = [await this.rest.getHubSphere()];
        }
        this.rest.cache.spheres = {};
        spheres.forEach((sphere) => {
            this.rest.cache.spheres[sphere.id] = sphere;
        });
        return spheres;
    }
    async resolveIdentifier() {
        var _a, _b, _c, _d;
        this.sphereIds = [];
        let spheres = this.rest.cache.findSpheres(this.filter);
        if (spheres.length > 0) {
            spheres.forEach((sphere) => { this.sphereIds.push(sphere.id); });
            return;
        }
        if (typeof this.filter === 'string') {
            // possibly ID
            if (this.filter.length === 24) {
                try {
                    let sphere = await this.rest.getSphere(this.filter);
                    this.rest.cache.spheres[sphere.id] = sphere;
                    this.sphereIds.push(sphere.id);
                    return;
                }
                catch (e) {
                    if (((_d = (_c = (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.request) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.statusCode) !== 401) {
                        throw e;
                    }
                }
            }
        }
        // if we do not have any sphere with this description, check if we have to download all of them.
        if (this.rest.cache.downloadedAll['spheres'] === false) {
            await this.downloadAllSpheres();
            let spheres = this.rest.cache.findSpheres(this.filter);
            if (spheres.length > 0) {
                spheres.forEach((sphere) => { this.sphereIds.push(sphere.id); });
                return;
            }
        }
        throw { code: 404, type: "spheres", message: "Could not find Spheres(s) with this filter: " + this.filter };
    }
    crownstones(filter) {
        return new crownstones_1.Crownstones(this.rest, this, null, filter);
    }
    locations(filter) {
        return new locations_1.Locations(this.rest, this, filter);
    }
    users() {
    }
    async keys() {
        let keys = [];
        if (this.rest.cache.keys !== null) {
            keys = this.rest.cache.keys;
        }
        else {
            keys = await this.rest.getKeys();
        }
        if (this.sphereIds.length === 0) {
            await this.data();
        }
        let requiredKeys = [];
        this.sphereIds.forEach((sphereId) => {
            for (let i = 0; i < keys.length; i++) {
                if (keys[i].sphereId === sphereId) {
                    requiredKeys.push(keys[i]);
                    return;
                }
            }
        });
        return requiredKeys;
    }
    async data() {
        // if we have a filter and resolved sphereIds, we should also have the spheres in cache.
        if (this.filter !== null && this.sphereIds.length > 0) {
            let result = [];
            this.sphereIds.forEach((sphereId) => {
                result.push(this.rest.cache.spheres[sphereId]);
            });
            return result;
        }
        // we do not have resolved the filter to sphere ids yet, do that first and retry
        else if (this.filter !== null && this.sphereIds.length === 0) {
            await this.resolveIdentifier();
            return this.data();
        }
        // there is no filter, just return the spheres.
        else if (this.filter === null) {
            if (this.rest.cache.downloadedAll['spheres']) {
                this.sphereIds = Object.keys(this.rest.cache.spheres);
                return cache_1.listCache(this.rest.cache.spheres);
            }
            await this.downloadAllSpheres();
            return await this.data();
        }
        return [];
    }
    async refresh() {
        await this.downloadAllSpheres();
        return this;
    }
}
exports.Spheres = Spheres;
//# sourceMappingURL=Spheres.js.map