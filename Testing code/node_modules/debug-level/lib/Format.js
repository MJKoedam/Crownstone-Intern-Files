'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var stringify = require('json-stringify-safe');

var replacer = function replacer(key, value) {
  if (value instanceof Error) {
    return value.stack || value.name + ' ' + value.message;
  }
  return value;
};

var jFormatter = function jFormatter(obj, spaces) {
  return stringify(obj, replacer, spaces);
};

var formatters = {
  s: function s(arg) {
    return String(arg);
  },
  d: function d(arg) {
    return Number(arg);
  },
  i: function i(arg) {
    return parseInt(arg, 10);
  },
  f: function f(arg) {
    return parseFloat(arg);
  },
  j: jFormatter,
  o: jFormatter,
  O: jFormatter
};

module.exports = Format;

/**
 * @param {object} [opts]
 * @param {boolean} [opts.noQuotes] - remove quotes from object keys
 * @param {number} [opts.spaces] - JSON.stringify spaces
 * @param {object} [opts.formatters] - custom formatters (if needed)
 */
function Format() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  Object.assign(this, {
    opts: opts,
    formatters: Object.assign(formatters, opts.formatters)
  });
}

Format.prototype = {
  get noQuotes() {
    return this.opts.noQuotes;
  },
  set noQuotes(val) {
    this.opts.noQuotes = !!val;
  },

  get spaces() {
    return this.opts.spaces;
  },
  set spaces(spaces) {
    this.opts.spaces = spaces;
  },

  /**
   * formats arguments like `util.format`
   * @param {...Any} arguments list - args[0] may contain "%" formatters
   * @return {Array} first is formatted message, other args may follow
   */
  format: function format() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    switch (_typeof(args[0])) {
      case 'string':
        break;
      case 'number':
        args.unshift('%d');
        break;
      case 'boolean':
        args.unshift('%s');
        break;
      default:
        args.unshift('%O');
    }

    // apply all `formatters`
    var idx = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // don't increase the array index on escaped %
      if (match === '%%') return match;
      idx++;
      var formatter = _this.formatters[format];
      if (typeof formatter === 'function') {
        var val = args[idx];
        match = formatter(val, _this.opts.spaces);
        if (_this.opts.noQuotes && typeof match === 'string') {
          match = match.replace(/^"/, '').replace(/"$/m, '');
        }
        args.splice(idx, 1); // remove `args[idx]` as being inlined
        idx--;
      }
      return match;
    });

    // return all remaining arguments - args[0] should be of type string, if there were formatters inside
    return args;
  }
};