'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var os = require('os');
var ms = require('ms');
var chalk = require('chalk');

var _require = require('./utils'),
    inspectOpts = _require.inspectOpts,
    saveOpts = _require.saveOpts,
    inspectNamespaces = _require.inspectNamespaces,
    selectColor = _require.selectColor,
    levelColors = _require.levelColors;

var LogBase = require('./LogBase');

var env = process.env.NODE_ENV || 'development';
var isDevEnv = /^dev/.test(env); // anything which starts with dev is seen as development env

/**
 * global log options
 */
var options = {
  level: undefined,
  namespaces: undefined,
  json: !isDevEnv, // log in json format
  serverinfo: !isDevEnv, // append server information
  hideDate: isDevEnv, // do not hide date from output
  colors: isDevEnv, // apply colors
  stream: process.stderr, // output stream
  spaces: null, // pretty print JSON
  splitLine: isDevEnv

  /**
   * creates a new logger
   * @constructor
   * @param {String} name - namespace of Logger
   */
};function Log(name, opts) {
  if (!(this instanceof Log)) return new Log(name, opts);
  Object.assign(options, inspectOpts(process.env), inspectNamespaces(process.env));
  LogBase.call(this, name, Object.assign({}, options, opts));
  var colorFn = function colorFn(n) {
    return chalk.hex(n);
  };
  this.color = selectColor(name, colorFn);
  this.levColors = levelColors(colorFn);
  if (!this.opts.json) {
    this._log = this._logOneLine;
  }
}
Object.setPrototypeOf(Log.prototype, LogBase.prototype);

Object.assign(Log.prototype, {
  /**
   * render string to output stream
   * @public
   * @param {String} str - string to render
   * @param {String} level - level of log line (might be used for custom Logger which uses different streams per level)
   * @return {String}
   */
  render: function render(str) {
    str += '\n';
    this.opts.stream.write(str);
    return str;
  },


  /**
   * format object to json
   * @private
   */
  _log: function _log(level, args) {
    var _this = this;

    this._diff();
    var o = this._formatJson(level, args);
    var str = this.formatter.format(o)[0];
    /* istanbul ignore next */ // can't cover with test as underlying tty is unknown
    if (this.opts.colors) {
      // this is slow...
      str = str.replace(/"level":\s?"([^"]+)"/, function (m, level) {
        return _this._color(m, _this.levColors[level], true);
      }).replace(/"name":\s?"[^"]+"/, function (m) {
        return _this._color(m, _this.color, true);
      });
    }
    return this.render(str, level);
  },


  /**
   * debug like output if `this.opts.json === false`
   * @private
   */
  _logOneLine: function _logOneLine(level, args) {
    this._diff();
    var str = this._formatArgs(level, args);
    return this.render(str, level);
  },


  /**
   * format arguments to debug like string
   * @private
   * @param {String} level
   * @param {Array} args - formatter arguments - first arg should contain "%" formatter directives
   * @return {String} formatted String
   */
  _formatArgs: function _formatArgs(level, _args) {
    var _formatter,
        _this2 = this;

    this.formatter.noQuotes = true;
    var args = (_formatter = this.formatter).format.apply(_formatter, _toConsumableArray(_args));
    var msg = args.shift();
    // if there are still unformatted args push through formatter and append to msg
    if (args.length) {
      msg += ' ' + args.map(function (arg) {
        return _this2.formatter.format('%O', arg);
      }).join(' ');
    }
    this.formatter.noQuotes = false;

    var prefix = '  ' + this._color(level, this.levColors[level], true) + ' ' + this._color(this.name, this.color, true);

    var str = [prefix, this.opts.hideDate ? '' : new Date().toISOString(), !this.opts.splitLine ? msg.replace(/[\r\n]/g, '\\n') : msg.split(/\\n|\n/).join('\n' + prefix + ' '), this._color('+' + ms(this.diff), this.color), this.opts.serverinfo ? os.hostname() + ' ' + process.pid : undefined].filter(function (f) {
      return f;
    }).join(' ');

    return str;
  },


  /**
   * Add colors, style to string
   * @private
   */
  _color: function _color(str, color, isBold) {
    return !this.opts.colors ? str : isBold ? color.bold(str) : color(str);
  },


  /**
   * append server info to json object - used by `_formatJson`
   * @private
   */
  _serverinfo: function _serverinfo(o) {
    // istanbul ignore else
    if (this.opts.serverinfo) {
      Object.assign(o, { hostname: os.hostname(), pid: process.pid });
    }
  }
});

/**
* Apply (and get) global options
* @param {object} [opts] - changed options
* @return {object} global options
*/
Log.options = function (opts) {
  if (!opts) return Object.assign({}, options);
  Object.assign(options, opts);
  return options;
};

/**
 * save options in `process.env`
 */
Log.save = function () {
  Log.reset();
  saveOpts(process.env, options);
};

/**
 * reset saved options
 */
Log.reset = function () {
  Object.keys(process.env).forEach(function (key) {
    if (/^(DEBUG|DEBUG_.*)$/.test(key)) {
      delete process.env[key];
    }
  });
};

Log.isDevEnv = isDevEnv;

module.exports = Log;