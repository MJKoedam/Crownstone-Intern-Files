"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require('crypto');
const eventsource_1 = __importDefault(require("eventsource"));
const shasum = crypto.createHash('sha1');
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const Logger_1 = require("./Logger");
const log = Logger_1.Logger(__filename);
exports.defaultHeaders = {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
};
;
const DEFAULT_URLS = {
    sseUrl: "https://events.crownstone.rocks/sse",
    loginUrl: "https://cloud.crownstone.rocks/api/users/login",
    hubLoginBase: "https://cloud.crownstone.rocks/api/Hubs/"
};
class CrownstoneSSE {
    constructor(options) {
        this.log = log;
        this.autoreconnect = false;
        this.eventSource = null;
        this.accessToken = null;
        this.checkerInterval = null;
        this.reconnectTimeout = null;
        this.pingTimeout = null;
        this.sse_url = DEFAULT_URLS.sseUrl;
        this.login_url = DEFAULT_URLS.loginUrl;
        this.hubLogin_baseUrl = DEFAULT_URLS.hubLoginBase;
        this.cachedLoginData = null;
        this.sse_url = options && options.sseUrl || DEFAULT_URLS.sseUrl;
        this.login_url = options && options.loginUrl || DEFAULT_URLS.loginUrl;
        this.hubLogin_baseUrl = options && options.hubLoginBase || DEFAULT_URLS.hubLoginBase;
        if (this.hubLogin_baseUrl.substr(-1, 1) !== '/') {
            this.hubLogin_baseUrl += "/";
        }
        this.autoreconnect = (options && options.autoreconnect !== undefined) ? options.autoreconnect : true;
    }
    async login(email, password) {
        shasum.update(password);
        let hashedPassword = shasum.digest('hex');
        return await this.loginHashed(email, hashedPassword);
    }
    async loginHashed(email, sha1passwordHash) {
        this.cachedLoginData = { user: { email: email, hashedPassword: sha1passwordHash } };
        return cross_fetch_1.default(this.login_url, { method: "POST", headers: exports.defaultHeaders, body: JSON.stringify({ email, password: sha1passwordHash }) })
            .then((result) => {
            return result.json();
        })
            .then((result) => {
            var _a;
            if (((_a = result === null || result === void 0 ? void 0 : result.error) === null || _a === void 0 ? void 0 : _a.statusCode) == 401) {
                throw result.error;
            }
            this.accessToken = result.id;
            log.info("SSE user login successful.");
        })
            .catch((err) => {
            log.warn("SSE user login failed.", err);
            if ((err === null || err === void 0 ? void 0 : err.code) === "LOGIN_FAILED_EMAIL_NOT_VERIFIED") {
                console.info("This email address has not been verified yet.");
                throw err;
            }
            else if ((err === null || err === void 0 ? void 0 : err.code) === "LOGIN_FAILED") {
                console.info("Incorrect email/password");
                throw err;
            }
            else {
                console.error("Unknown error while trying to login to", this.login_url);
                throw err;
            }
        });
    }
    async hubLogin(hubId, hubToken) {
        this.cachedLoginData = { hub: { hubId: hubId, hubToken: hubToken } };
        let combinedUrl = this.hubLogin_baseUrl + hubId + '/login?token=' + hubToken;
        return cross_fetch_1.default(combinedUrl, { method: "POST", headers: exports.defaultHeaders })
            .then((result) => {
            return result.json();
        })
            .then((result) => {
            var _a;
            if (((_a = result === null || result === void 0 ? void 0 : result.error) === null || _a === void 0 ? void 0 : _a.statusCode) == 401) {
                throw result.error;
            }
            this.accessToken = result.id;
            log.info("SSE hub login successful.");
        })
            .catch((err) => {
            log.warn("SSE hub login failed.", err);
            if ((err === null || err === void 0 ? void 0 : err.code) === "LOGIN_FAILED") {
                console.info("Incorrect email/password");
                throw err;
            }
            else {
                console.error("Unknown error while trying to login to", combinedUrl);
                throw err;
            }
        });
    }
    async retryLogin() {
        if (this.cachedLoginData.hub !== undefined) {
            return this.hubLogin(this.cachedLoginData.hub.hubId, this.cachedLoginData.hub.hubToken);
        }
        else if (this.cachedLoginData.user !== undefined) {
            return this.loginHashed(this.cachedLoginData.user.email, this.cachedLoginData.user.hashedPassword);
        }
        throw "NO_CREDENTIALS";
    }
    setAccessToken(token) {
        this.accessToken = token;
    }
    stop() {
        this._clearPendingActions();
        this.autoreconnect = false;
        if (this.eventSource !== null) {
            this.eventSource.close();
        }
    }
    /**
     * The cloud will ping every 30 seconds. If this is not received after 40 seconds, we restart the connection.
     * @private
     */
    _messageReceived() {
        clearTimeout(this.pingTimeout);
        this.pingTimeout = setTimeout(() => {
            if (this.eventCallback !== undefined) {
                this.start(this.eventCallback);
            }
        }, 40000);
    }
    _clearPendingActions() {
        clearInterval(this.checkerInterval);
        clearTimeout(this.reconnectTimeout);
        clearTimeout(this.pingTimeout);
    }
    async start(eventCallback) {
        if (this.accessToken === null) {
            throw "AccessToken is required. Use .setAccessToken() or .login() to set one.";
        }
        this.eventCallback = eventCallback;
        this._clearPendingActions();
        if (this.eventSource !== null) {
            log.info("Event source closed before starting again.");
            this.eventSource.close();
        }
        return new Promise((resolve, reject) => {
            this.eventSource = new eventsource_1.default(this.sse_url + "?accessToken=" + this.accessToken);
            this.eventSource.onopen = (event) => {
                log.info("Event source connection established.");
                this._messageReceived();
                this.checkerInterval = setInterval(() => {
                    if (this.eventSource.readyState === 2) { // 2 == CLOSED
                        log.warn("Recovering connection....");
                        this.start(this.eventCallback);
                    }
                }, 1000);
                resolve();
            };
            this.eventSource.onmessage = (event) => {
                // bump the heartbeat timer.
                this._messageReceived();
                if (event === null || event === void 0 ? void 0 : event.data) {
                    let message = JSON.parse(event.data);
                    log.debug("Event received", message);
                    this.eventCallback(message);
                    // attempt to automatically reconnect if the token has expired.
                    if (message.type === 'system' && message.code === 401 && message.subType == "TOKEN_EXPIRED") {
                        this.eventSource.close();
                        this._clearPendingActions();
                        if (this.autoreconnect && this.cachedLoginData) {
                            try {
                                log.debug("Attempting to login again since our token expired...");
                                return this.retryLogin()
                                    .then(() => {
                                    log.debug("Done...");
                                    return new Promise((resolve, reject) => { setTimeout(resolve, 2000); });
                                })
                                    .then(() => {
                                    log.debug("Retry with new token...");
                                    return this.start(this.eventCallback);
                                })
                                    .then(() => {
                                    log.debug("Done...");
                                });
                            }
                            catch (e) {
                                let errorEvent = {
                                    type: "system",
                                    subType: "COULD_NOT_REFRESH_TOKEN",
                                    code: 401,
                                    message: "Token expired, autoreconnect tried to get a new one. This was not successful. Connection closed.",
                                };
                                log.error(errorEvent);
                                this.eventCallback(errorEvent);
                            }
                        }
                        else {
                            let errorEvent = {
                                type: "system",
                                subType: "COULD_NOT_REFRESH_TOKEN",
                                code: 401,
                                message: "Token expired, autoconnect is disabled or does not have login credentials. Connection closed.",
                            };
                            log.error(errorEvent);
                            this.eventCallback(errorEvent);
                        }
                    }
                }
            };
            this.eventSource.onerror = (event) => {
                clearInterval(this.checkerInterval);
                clearTimeout(this.reconnectTimeout);
                log.warn("Eventsource error", event);
                log.info("Reconnecting after error. Will start in 2 seconds.");
                this.reconnectTimeout = setTimeout(() => { this.start(this.eventCallback); }, 2000);
            };
        });
    }
}
exports.CrownstoneSSE = CrownstoneSSE;
//# sourceMappingURL=CrownstoneSSE.js.map