'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('url'),
    urlParse = _require.parse;

var _require2 = require('querystring'),
    qsParse = _require2.parse;

var MapLRU = require('map-lru').default;
var Log = require('./node');

var _require3 = require('./utils'),
    adjustLevel = _require3.adjustLevel,
    DEBUG = _require3.DEBUG;

// https://css-tricks.com/snippets/html/base64-encode-of-1x1px-transparent-gif/


var gif = Buffer.from('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7', 'base64');

var Loggers = function () {
  function Loggers() {
    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;

    _classCallCheck(this, Loggers);

    this.cache = new MapLRU(maxSize);
  }

  _createClass(Loggers, [{
    key: 'get',
    value: function get(name) {
      var log = this.cache.get(name);
      if (!log) {
        log = new Log(name);
        this.cache.set(name, log);
      }
      return log;
    }
  }]);

  return Loggers;
}();

// custom logger to use formatter and stream


function CustomLog() {
  Log.call(this, '---');
}
Object.setPrototypeOf(CustomLog.prototype, Log.prototype);
CustomLog.prototype.log = function (obj) {
  var str = this.formatter.format(obj);
  this.render(str);
};

module.exports = middleware;

/**
 * connect middleware which logs browser based logs on server side
 * sends a transparent gif as response
 * @param {Object} [opts]
 * @param {Object} [opts.maxSize=100] - max number of different name loggers
 * @param {Object} [opts.logAll=false] - log everything even strings
 * @return {function} connect middleware
 */
function middleware(opts) {
  opts = Object.assign({ maxSize: 100, logAll: false }, opts);
  var log = opts.logAll ? new CustomLog() : undefined;
  var loggers = new Loggers(opts.maxSize);

  return function (req, res) {
    var query = req.query;
    if (!req.query) {
      query = qsParse(urlParse(req.url).query);
    }
    res.setHeader('Cache-Control', 'no-store, no-cache');
    res.write(gif);
    res.end();

    var str = query.log;
    if (!str) return;

    if (/^{.*?}\s*$/.test(str)) {
      // check if `str` looks like JSON
      try {
        var obj = JSON.parse(str);
        var level = adjustLevel(String(obj.level), DEBUG);
        var name = String(obj.name).substr(0, 50);
        if (obj.name && name) {
          var l = loggers.get(name);
          if (l.enabled[level]) {
            if (req.ip) obj.ip = req.ip;
            delete obj.name;
            delete obj.level;
            l._log(level, [obj]);
          }
          return;
        }
      } catch (e) {}
    }

    log && log.log(str);
  };
}